**Чем отличается git pull от git fetch?**

* git fetch лишь загружает данные, но не изменяет вашу текущую рабочую ветку.
* git pull загружает и сразу же сливает изменения с вашей рабочей веткой, что может повлиять на её состояние.

**Что такое rebase и чем он отличается от merge?**
* git merge — это команда, которая сливает изменения из одной ветки в другую, создавая слияние (merge commit).
* git rebase — это команда, которая переписывает историю, перемещая коммиты из одной ветки на начало другой.

| Характеристика         | git merge                                    | git rebase                                |
|------------------------|-----------------------------------------------|-------------------------------------------|
| **Тип коммита**        | Создаёт новый коммит слияния (merge commit).   | Переписывает историю, создавая новые коммиты. |
| **История**            | Сохраняет всю историю веток.                  | История становится линейной, как будто изменений не было в нескольких ветках. |
| **Конфликты**          | Конфликты могут быть решены в процессе слияния. | Конфликты могут возникать на каждом коммите в процессе ребейса. |
| **Использование**      | Хорошо подходит для слияния больших изменений, чтобы сохранить историю. | Подходит для «чистоты» истории, когда нужно линейно интегрировать изменения. |


**Что делает команда git cherry-pick и в каких случаях она используется?**

Команда git cherry-pick в Git позволяет переносить отдельные коммиты из одной ветки в другую. Вместо того чтобы сливать все изменения между ветками, как это делает git merge, или переписывать историю, как в случае с git rebase, git cherry-pick позволяет вам выбрать конкретные коммиты и применить их к текущей ветке.

**Чем git reset --soft, git reset --mixed и git reset --hard отличаются друг от друга?**

**git reset --soft**
Что делает?
Перемещает HEAD на указанный коммит.
Оставляет изменения в индексе (staging area).
Не затрагивает рабочую директорию (файлы остаются как есть).
Когда использовать?
Если вы хотите изменить последний коммит (git commit --amend).
Если хотите объединить несколько коммитов перед git commit.

**git reset --mixed (по умолчанию)**
Что делает?
Перемещает HEAD на указанный коммит.
Очищает индекс (staging area) (файлы становятся неотслеживаемыми).
Не затрагивает рабочую директорию (файлы остаются без изменений).
Когда использовать?
Если нужно отменить коммит и разотметить файлы (git add).
Чтобы начать заново без удаления изменений.

**git reset --hard**
Что делает?
Перемещает HEAD на указанный коммит.
Очищает индекс (staging area).
Удаляет все изменения из рабочей директории! (⚠ необратимо).
Когда использовать?
Если хотите полностью отменить изменения (как будто их не было).
Если хотите сбросить ветку к старому состоянию.

**Что делает git revert, и в чем его отличие от git reset?**

Команда git revert создаёт новый коммит, который отменяет изменения из указанного коммита.
Она не изменяет историю, поэтому безопасна для использования в публичных репозиториях.

Как работает git revert?

`git revert <commit_hash>`

**Как отменить старый коммит с помощью git revert, если после него было сделано несколько новых коммитов?**

Если после коммита A (abc1234) были сделаны коммиты B, C и D, и вам нужно отменить только A, выполняем команду:

`git revert abc1234`

Находим коммиты `git log --oneline`

**Как использовать git revert для отмены нескольких коммитов сразу?**

. Отмена нескольких коммитов по их хешам
Если вам нужно отменить несколько несмежных коммитов, укажите их хеши через пробел:

`git revert <commit1> <commit2> <commit3>
`
**Как использовать git revert для отката изменений только в конкретном файле?**

`git log --oneline -- <file>`

Можно использовать git checkout или git restore, чтобы взять старую версию файла:

git checkout a1b2c3d~1 -- main.py

git restore --source=a1b2c3d~1 -- main.py

**Как просмотреть список коммитов, которые можно безопасно перенести с помощью git cherry-pick?**

Чтобы использовать git cherry-pick, нужно определить список коммитов, которые можно безопасно перенести из одной ветки в другую.

git log --oneline main..dev


**В чем разница между git merge --squash и git rebase -i?**

| Функция           | `git merge --squash`                                      | `git rebase -i`                                      |
|-------------------|-----------------------------------------------------------|------------------------------------------------------|
| **Как работает**  | Объединяет коммиты из одной ветки, но не создаёт merge-коммит. | Позволяет изменять историю, в том числе объединять коммиты. |
| **История**       | История остаётся разветвлённой (но без merge-коммита).    | История становится линейной (изменяет существующие коммиты). |
| **Когда применять** | При подготовке чистого коммита перед мёрджем в основную ветку. | Для редактирования истории своей ветки до её объединения. |
| **Откат изменений** | Можно отменить перед коммитом.                          | После изменения истории отменить сложнее.           |
| **Использование**  | `git merge --squash feature-branch`                      | `git rebase -i HEAD~N`                              |


**Какие проблемы могут возникнуть при использовании git cherry-pick в команде с несколькими разработчиками?**

Если позже сделать git merge между этими ветками, Git не распознает общий предок и может вызвать конфликты или создать дублирующие коммиты.

Cherry-picking старого коммита в новую ветку, где код изменился, может привести к сложным конфликтам.

git cherry-pick переносит только один коммит, но он может зависеть от других коммитов в исходной ветке.

`git log --oneline --graph
`
